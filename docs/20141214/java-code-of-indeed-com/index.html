
<html>
<head>
    <title>Indeed.com の Java コード</title>
</head>
<body>
<a href="http://www.susumuis.info/entry/2014/advent_calendar_java" target="_blank">10年間Javaを書いていた僕が Effective Java 第2版を読み返して新人に薦められるのかを考えてみた</a>という記事に寄せて、ここ 1 年半くらい働いている<a href="http://www.indeed.com/" target="_blank">Indeed.com</a>の環境をシェアしたら面白いのではないかと思ったので記事を書きました。<br>
<br>
Effective Java に対するコメントでは無く、Effective Java に対する、上記記事のコメントに対するコメントです。なので、未読であれば上記記事を先に読んだ方が話が分かりやすいかと思います。<br>
<br>
環境で言うと、以下のような環境です。まあ前提が大分違うので、結論も違って当たり前なのですが、そういうものもあるんだと参考にしてもらえればと思います。<br>
<br>
<ul>
	<li>バージョン管理には git を採用している。</li>
	<li>基本自分のメインとなるプロダクトはあるものの、どこのプロダクトにあるどのコードに対しても誰でもコミット・プッシュして、マージリクエストを送って良い (権限としてはマージも可能だけれども、そこは紳士協定。)</li>
	<li>1つのプロダクトは平均して3〜4人、色んな人がいじりたがる全社でメインのプロダクトだと、同時 (同じ週) に10人以上がコードをいじる事もある。</li>
	<li>全てのプログラマが、Effective Java 的な本を読んでいるわけではないが、素養としては間違いなくそれを使いこなせるレベルにある。</li>
	<li>全てのコードは (コメントを消す、import を整理するなどの超基本的なものを除き) 誰かしらにコードレビューをされてからマージされる。</li>
	<li>プロダクトは jar として利用されるライブラリと、それ自体が war としてウェブアプリになるものとに分かれている。</li>
	<li>週 1 以上、頻繁に本番リリースされるので、アジャイル的な開発工程になっている。</li>
</ul>
<br>
<h4>項目 1 コンストラクタの代わりに static ファクトリーメソッドを検討する <br>項目 2 数多くのコンストラクタパラメータに直面した時にはビルダーを検討する</h4>
<br>
これは相当実践されてるなという感じです。上述の環境からかなり防御的なプログラミングが多く、不変クラスを実現するためにビルダーがよく使われます。<br>
Google Guava とか、Google Protobuf を好んで使っている職場な事もあって、Builder の命名などはそれに習っているので、使う側になった場合もそんなに困ることはありません。<br>
<br>
<h4>項目 3 private のコンストラクタか enum 型でシングルトン特性を強制する</h4>
<br>
enum でシングルトンを強制する、というか言語上 enum のシングルトンが保証されている、という理解ですが、シングルトンにするために enum を使うというよりは、enum が適切なシーンでは極力 enum を使っていく事が多いです。<br>
<br>
例えば、パラメータとして取りうる値が 3 種類なら、それは 3 種の値を持った enum が妥当だよね、という感じです。String でパラメータを受けるようにしちゃうと、バリデーションのロジックと実際の処理を行うロジックがまぜこぜに "してしまいがち" になるけれど、enum だったらそこは強制的に分かれるし見通しが良いね、とか、ライブラリに渡したり、他のロジックから受け取るときも enum なら "それらの値にしかなり得ないことが保証されている" から安心っていうのもあります。<br>
細かいところだと、必要なところで EnumSet とかを使うとパフォーマンスも有利だしとかまあ色々です。<br>
<br>
シングルトン云々の話題からは離れてしまいましたね。純粋なシングルトンでないとどうしてもいけないっていうケースは確かに出会ったことないです。<br>
パフォーマンス上、シングルトンにしておくと有利だからそうする、みたいなケースがほとんどじゃないでしょうか。<br>
<br>
<h4>項目 4 private のコンストラクタでインスタンス化不可能を強制する</h4>
<br>
これはケースバイケース。常に private にするなんて窮屈すぎるので、public コンストラクタも普通に使って良いと思ってます。もちろんファクトリ、ビルダーの時は private にして当然ですが、シンプルなクラスだったらそんなに目くじら立てる事もないのかなぁと。DI して interface と implements を切り分けるときはまた別のお話ですね。<br>
まあ過去の経験から言えば、参加するエンジニアのレベルが予測できない場合の防御策としてはありと思います。<br>
<br>
<h4>項目 5 不必要なオブジェクトの生成を避ける</h4>
<br>
こういうのは、基本やっておいて損はないのかなと思ってます。特にライブラリ寄りだと、そいつはループの中から呼ばれるかも知れないぜ？っていうのもあるので、不変オブジェクトを static private に追い出すとかは良くやります。昨今、メモリの方が CPU より安いと考えた方が良いケースも多いですし。ただ、Web やってる人はマルチスレッドのことを常に忘れてはいけませんね。<br>
<br>
<h4>項目 6 廃れたオブジェクト参照を取り除く</h4>
<br>
同意。こんなん Web サービスで残しておいたら命取りです。<br>
<br>
<h4>項目 7 ファイナライザを避ける</h4>
<br>
ファイナライザ？何それ美味しいの？<br>
<br>
<h4>項目 8 equals をオーバーライドする時は一般契約に従う<br>項目 9 equals をオーバーライドする時は、常に hashCode をオーバーライドする</h4>
<br>
ちゃんとやりますよ。equals のオーバーライド自体滅多にやらないですけどね。<br>
<br>
<br>
<h4>項目 10 toString を常にオーバーライドする</h4>
<br>
いや、これはやらない方がいいんじゃ？toDebugString とか toHtml とか toJsonString とか目的別の名前推奨したいです。<br>
<br>
<h4>項目 11 clone を注意してオーバーライドする</h4>
<br>
clone はもうレガシー。ファイナライザくらい何それ (ry という世界な気がします。<br>
それとか、コピーが欲しいクラスでビルダーが採用されてたりしたら、MyClass.Builder.of(instance).build(); 的な感じになったりします。<br>
<br>
<h4>項目 12 Comparable の実装を検討する</h4>
<br>
compareTo 実装するなら、equals とか hashCode も一緒に実装したいところですね。<br>
<br>
<h4>項目 13 クラスとメンバーへのアクセス可能性を最小限にする<br>項目 14 public のクラスでは、public のフィールドではなく、アクセッサーメソッドを使う<br>項目 15 可変性を最小限にする</h4>
<br>
これは最初に書いた現在の開発環境に大きく影響を受けてますが、ガンガンにそうしてます。あとからやっぱ private じゃない方が良かったー！ってなったら、その時に親クラスの方を変えてしまえる環境だからですね。ただ Unit Test を書くための package private (デフォルト) もよく使います。とはいえその時は必ず、@VisibleForTesting アノテーションを付けるようにする、っていうくらい private に出来るものは極力そうするっていう感じです。<br>
<br>
<h4>項目 16 継承よりコンポジションを選ぶ</h4>
<br>
ケースバイケースですかねー。個人的には、閉じた単一プロダクトの中では継承。コード全体の見通しが悪くなる外部ライブラリ内のクラスに対しては移譲、っていう使い分けが多いように思いますが、例外もいっぱいです。<br>
そもそも、前述の通りの環境なので、移譲が必要そうになったらライブラリ側に手を入れてそっちで継承させてしまったり、という事もしますし。<br>
<br>
<h4>項目 17 継承のために設計および文書化する、でなければ継承を禁止する</h4>
<br>
あぁ、この辺ゆるいですね。いいんだか悪いんだか、昨今の IDE の静的解析が優秀なので、ドキュメントがなくてもソースが簡単に追えるからぶっちゃけ困ってないというか、いやドキュメントがあった方が最初は楽なんだろうけど、それが最新状態とは誰も保証してくれないから結局ソース読むよね、っていう。<br>
その辺を意識してか、全社のコードリポジトリの全文検索エンジンがあったり、jar をリポジトリから依存解決するときに、デフォルトでソースもセットで落ちてくるようになってたり、なるべく少ないコストでソース追えるような環境にはなってます。<br>
<br>
<h4>まとめ</h4>
<br>
元記事読んで思ったのは、Indeed の開発環境はやはり防御的だな、という感じです。これまでに働いていた環境ではここまでというのは無かったのですが、まあ慣れてしまえば書くのもおっくうじゃないですし、メリットを享受するだけになるので、そういうスタイルが普通になってきました。<br>
こういうスタイルで書きながらも、高速な開発サイクルを回せてるのはすげぇなぁと思うところです。<br>
<br>
そういえば、Java は開発おせーんだよ、Python 使え Ruby 使えだのいう話がありますよね。<br>
でも一方で、じゃあそれらは過酷なパフォーマンス負荷に耐えられるんだっけ？という話もあったり、言語にこだわるよりいわゆる 10 倍速いプログラマ雇うことにこだわった方がいいんじゃない？とか、Java はもはや IDE とセットで一つの言語と言っても過言で無いので、IDE まで含めて考えると言うほど生産性悪くないよ？むしろ静的解析のおかげで、コードベースが大きくなったときは明らかに Java の方が楽だよ？とか色々です。<br>
トータルで見るとまだまだ Java の牙城は揺るがないのかなぁと思います。<br>
<br>
Effective Java の話に戻ると、なんだかんだ今の自分の思考/指向とも合致することが多いので、初学者にも勧めて良い本だなと、元記事と同じ結論になりました。<br>

</body>
</html>
